<!DOCTYPE html>
<html lang="bn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ProMotion Editor Web</title>
    <!-- Google Fonts for Bengali Support (Hind Siliguri) & Icons -->
    <link href="https://fonts.googleapis.com/css2?family=Hind+Siliguri:wght@400;600;700&family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet">

    <style>
        :root {
            --bg-dark: #121212;
            --bg-panel: #1e1e1e;
            --accent: #00BFFF; /* Cyan blue from screenshots */
            --text-main: #ffffff;
            --text-sec: #aaaaaa;
            --timeline-track: #2a2a2a;
            --layer-blue: #2196F3;
            --layer-purple: #9C27B0;
            --layer-orange: #FF9800;
        }

        * { box-sizing: border-box; outline: none; -webkit-tap-highlight-color: transparent; user-select: none; }
        
        body {
            margin: 0;
            background-color: var(--bg-dark);
            color: var(--text-main);
            font-family: 'Poppins', 'Hind Siliguri', sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* --- PREVIEW AREA --- */
        #preview-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            position: relative;
            overflow: hidden;
        }

        canvas {
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            max-width: 100%;
            max-height: 100%;
        }

        /* --- TOOLBARS --- */
        .toolbar {
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            background: var(--bg-panel);
            border-bottom: 1px solid #333;
        }

        .btn {
            background: none;
            border: none;
            color: var(--text-main);
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .btn:active { background: rgba(255,255,255,0.1); }
        .btn.accent { color: var(--accent); }
        .btn-rect { 
            border-radius: 4px; padding: 5px 12px; font-size: 12px; font-weight: 600; 
            background: var(--accent); color: #000;
        }

        /* --- PROPERTIES PANEL --- */
        #properties-panel {
            height: 60px;
            background: var(--bg-panel);
            border-top: 1px solid #333;
            display: flex;
            align-items: center;
            overflow-x: auto;
            padding: 0 10px;
            gap: 10px;
        }

        .prop-group {
            display: flex;
            flex-direction: column;
            min-width: 60px;
            align-items: center;
        }
        .prop-label { font-size: 10px; color: var(--text-sec); margin-bottom: 4px; }
        input[type="range"] { width: 80px; accent-color: var(--accent); }
        input[type="color"] { border: none; width: 30px; height: 30px; background: none; }
        input[type="text"] { background: #333; border: none; color: white; padding: 4px; border-radius: 4px; width: 100px; }

        /* --- TIMELINE AREA --- */
        #timeline-area {
            height: 250px;
            background: var(--bg-dark);
            display: flex;
            flex-direction: column;
            border-top: 1px solid #333;
            position: relative;
        }

        #time-ruler {
            height: 30px;
            background: var(--bg-panel);
            border-bottom: 1px solid #333;
            position: relative;
            overflow: hidden;
        }

        #tracks-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: auto;
            position: relative;
            padding-top: 10px;
        }

        .layer-track {
            height: 35px;
            margin-bottom: 5px;
            position: relative;
            width: 2000px; /* Virtual width */
        }

        .layer-block {
            position: absolute;
            height: 100%;
            background: var(--layer-blue);
            border-radius: 4px;
            display: flex;
            align-items: center;
            padding: 0 10px;
            font-size: 12px;
            overflow: hidden;
            white-space: nowrap;
            border: 1px solid rgba(255,255,255,0.2);
            touch-action: none;
        }
        .layer-block.selected { border: 2px solid white; box-shadow: 0 0 5px var(--accent); }
        .layer-block.text { background: var(--layer-purple); }
        .layer-block.shape { background: var(--layer-orange); }

        #playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--accent);
            z-index: 10;
            pointer-events: none;
            left: 20px; /* Offset */
        }
        
        #playhead::after {
            content: ''; position: absolute; top: 0; left: -5px; 
            border-left: 6px solid transparent; border-right: 6px solid transparent; 
            border-top: 6px solid var(--accent);
        }

        /* --- MODALS --- */
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 100;
            display: none; justify-content: center; align-items: center;
        }
        .modal.active { display: flex; }
        .modal-content {
            background: var(--bg-panel); padding: 20px; border-radius: 10px; width: 80%;
            text-align: center;
        }

        /* --- LOADING --- */
        #loading { display: none; color: var(--accent); font-weight: bold; margin-top: 10px;}

    </style>
</head>
<body>

    <!-- TOP HEADER -->
    <div class="toolbar">
        <button class="btn" onclick="undo()"><span class="material-icons-round">undo</span></button>
        <div style="font-weight: 600;">ProEdit Lite</div>
        <button class="btn-rect" onclick="exportVideo()">EXPORT</button>
    </div>

    <!-- PREVIEW CANVAS -->
    <div id="preview-container">
        <canvas id="mainCanvas"></canvas>
    </div>

    <!-- MIDDLE CONTROLS -->
    <div class="toolbar" style="height: 40px; justify-content: center; gap: 20px;">
        <button class="btn" onclick="togglePlay()"><span class="material-icons-round" id="playIcon">play_arrow</span></button>
        <span id="time-display" style="font-size: 12px; font-family: monospace;">00:00.00</span>
    </div>

    <!-- PROPERTIES PANEL (Dynamic) -->
    <div id="properties-panel">
        <div style="color: #555; font-size: 12px; width: 100%; text-align: center;">Select a layer to edit</div>
    </div>

    <!-- TIMELINE -->
    <div id="timeline-area">
        <div id="time-ruler"></div>
        <div id="playhead"></div>
        <div id="tracks-container">
            <!-- Layers injected here -->
        </div>
    </div>

    <!-- BOTTOM ADD BAR -->
    <div class="toolbar" style="border-top: 1px solid #333;">
        <button class="btn" onclick="addLayer('text')"><span class="material-icons-round">title</span></button>
        <button class="btn" onclick="addLayer('shape')"><span class="material-icons-round">star</span></button>
        <button class="btn" onclick="document.getElementById('img-upload').click()"><span class="material-icons-round">image</span></button>
        <button class="btn" onclick="applyTemplate()"><span class="material-icons-round">auto_fix_high</span></button> <!-- Quick Template -->
    </div>

    <input type="file" id="img-upload" hidden accept="image/*">

    <!-- EXPORT MODAL -->
    <div class="modal" id="exportModal">
        <div class="modal-content">
            <h3>Rendering Video...</h3>
            <p>Please wait. Do not close browser.</p>
            <div id="loading">0%</div>
        </div>
    </div>

<script>
/**
 * CORE ARCHITECTURE
 * 1. State Management: Central store for layers, settings.
 * 2. Renderer: HTML5 Canvas loop (requestAnimationFrame).
 * 3. Timeline: Maps visual blocks to layer start/end times.
 * 4. Interaction: Touch/Mouse events for transformer & timeline.
 */

// --- CONFIGURATION ---
const CANVAS_WIDTH = 1280;
const CANVAS_HEIGHT = 720;
const FPS = 30;
const PX_PER_SECOND = 100; // Timeline zoom level

// --- STATE ---
let state = {
    layers: [],
    currentTime: 0, // in seconds
    duration: 10, // seconds
    isPlaying: false,
    selectedLayerId: null,
    backgroundColor: '#00BFFF' // Default Cyan from screenshot
};

let history = []; // Undo stack
let canvas, ctx;
let animationFrameId;

// --- INITIALIZATION ---
window.onload = () => {
    canvas = document.getElementById('mainCanvas');
    ctx = canvas.getContext('2d');
    
    // Set resolution
    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;

    // Responsive Canvas
    fitCanvas();
    window.addEventListener('resize', fitCanvas);

    // Setup Event Listeners
    setupTimelineEvents();
    document.getElementById('img-upload').addEventListener('change', handleImageUpload);

    // Start Render Loop
    renderLoop();
    renderTimeline();

    // Init with a demo layer
    addLayer('text', "রাখো না"); // Bengali Text
};

function fitCanvas() {
    const container = document.getElementById('preview-container');
    const aspect = CANVAS_WIDTH / CANVAS_HEIGHT;
    let w = container.clientWidth;
    let h = container.clientHeight;
    
    if (w / h > aspect) {
        w = h * aspect;
    } else {
        h = w / aspect;
    }
    
    canvas.style.width = `${w}px`;
    canvas.style.height = `${h}px`;
}

// --- LAYER SYSTEM ---
class Layer {
    constructor(type) {
        this.id = Date.now() + Math.random();
        this.type = type;
        this.name = type;
        this.startTime = 0;
        this.duration = 5;
        this.x = CANVAS_WIDTH / 2;
        this.y = CANVAS_HEIGHT / 2;
        this.scale = 1;
        this.rotation = 0;
        this.opacity = 1;
        this.visible = true;
    }
}

class TextLayer extends Layer {
    constructor(text) {
        super('text');
        this.text = text;
        this.fontSize = 80;
        this.color = '#00BFFF'; // Blue text
        this.fontFamily = 'Hind Siliguri';
        this.stroke = true;
        this.strokeColor = '#ffffff'; // White stroke
        this.strokeWidth = 4;
        this.shadow = false;
    }
}

class ShapeLayer extends Layer {
    constructor(shapeType) {
        super('shape');
        this.shapeType = shapeType; // 'star', 'rect', 'circle'
        this.color = '#ffffff';
        this.width = 200;
        this.height = 200;
    }
}

class ImageLayer extends Layer {
    constructor(imgElement) {
        super('image');
        this.img = imgElement;
        this.width = imgElement.naturalWidth;
        this.height = imgElement.naturalHeight;
        // Resize if too big
        if(this.width > 500) {
            let ratio = 500 / this.width;
            this.width = 500;
            this.height = this.height * ratio;
        }
    }
}

// --- ACTIONS ---

function addLayer(type, content = null) {
    let layer;
    if (type === 'text') {
        layer = new TextLayer(content || 'নতুন টেক্সট'); // New Text
    } else if (type === 'shape') {
        layer = new ShapeLayer('star'); // Default to star
    }
    
    if(layer) {
        layer.startTime = state.currentTime;
        state.layers.push(layer);
        state.selectedLayerId = layer.id;
        renderTimeline();
        updatePropertiesPanel();
    }
}

function handleImageUpload(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (event) => {
        const img = new Image();
        img.onload = () => {
            const layer = new ImageLayer(img);
            layer.startTime = state.currentTime;
            state.layers.push(layer);
            renderTimeline();
        };
        img.src = event.target.result;
    };
    reader.readAsDataURL(file);
}

// Mimic the screenshots style automatically
function applyTemplate() {
    state.layers = [];
    state.backgroundColor = '#00BFFF'; // The blue background
    
    // 1. White Box
    let box = new ShapeLayer('rect');
    box.color = '#ffffff';
    box.width = 600; box.height = 300;
    box.rotation = -5;
    state.layers.push(box);

    // 2. Stars
    for(let i=0; i<5; i++) {
        let star = new ShapeLayer('star');
        star.color = '#ffffff'; // White stars
        star.scale = 0.5 + Math.random() * 0.5;
        star.x = Math.random() * CANVAS_WIDTH;
        star.y = Math.random() * CANVAS_HEIGHT;
        // Simple animation logic would go here (omitted for single-file simplicity)
        state.layers.push(star);
    }

    // 3. Text
    let txt = new TextLayer("বসো না");
    txt.fontSize = 100;
    txt.color = '#00BFFF'; // Blue text
    txt.stroke = false;
    txt.rotation = -5;
    state.layers.push(txt);

    let subTxt = new TextLayer("চুপটি করে");
    subTxt.fontSize = 60;
    subTxt.color = '#ffffff';
    subTxt.y = CANVAS_HEIGHT/2 + 150;
    state.layers.push(subTxt);

    renderTimeline();
}

// --- RENDER ENGINE (The Core) ---

function renderLoop() {
    if (state.isPlaying) {
        state.currentTime += 1 / FPS;
        if (state.currentTime >= state.duration) {
            state.currentTime = 0;
            state.isPlaying = false;
            document.getElementById('playIcon').innerText = 'play_arrow';
        }
        updatePlayheadUI();
    }
    
    drawFrame();
    
    animationFrameId = requestAnimationFrame(renderLoop);
}

function drawFrame() {
    // Clear
    ctx.fillStyle = state.backgroundColor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Sort layers by Z-index (array order)
    state.layers.forEach(layer => {
        if (!layer.visible) return;
        // Time Check
        if (state.currentTime < layer.startTime || state.currentTime > layer.startTime + layer.duration) return;

        ctx.save();
        
        // Transforms
        ctx.translate(layer.x, layer.y);
        ctx.rotate(layer.rotation * Math.PI / 180);
        ctx.scale(layer.scale, layer.scale);
        ctx.globalAlpha = layer.opacity;

        // Draw Content
        if (layer.type === 'text') {
            ctx.font = `700 ${layer.fontSize}px '${layer.fontFamily}'`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            if (layer.stroke) {
                ctx.strokeStyle = layer.strokeColor;
                ctx.lineWidth = layer.strokeWidth;
                ctx.strokeText(layer.text, 0, 0);
            }
            
            ctx.fillStyle = layer.color;
            ctx.fillText(layer.text, 0, 0);
        } 
        else if (layer.type === 'image') {
            ctx.drawImage(layer.img, -layer.width/2, -layer.height/2, layer.width, layer.height);
        } 
        else if (layer.type === 'shape') {
            ctx.fillStyle = layer.color;
            if(layer.shapeType === 'rect') {
                ctx.fillRect(-layer.width/2, -layer.height/2, layer.width, layer.height);
            } else if (layer.shapeType === 'star') {
                drawStar(ctx, 0, 0, 5, layer.width/2, layer.width/4);
            }
        }

        // Selection Highlight
        if (state.selectedLayerId === layer.id) {
            ctx.strokeStyle = '#00FF00';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 5]);
            // Draw crude bounding box
            ctx.strokeRect(-100, -50, 200, 100); // Ideally calculated based on content
        }

        ctx.restore();
    });
}

function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
    let rot = Math.PI / 2 * 3;
    let x = cx;
    let y = cy;
    let step = Math.PI / spikes;

    ctx.beginPath();
    ctx.moveTo(cx, cy - outerRadius);
    for (let i = 0; i < spikes; i++) {
        x = cx + Math.cos(rot) * outerRadius;
        y = cy + Math.sin(rot) * outerRadius;
        ctx.lineTo(x, y);
        rot += step;

        x = cx + Math.cos(rot) * innerRadius;
        y = cy + Math.sin(rot) * innerRadius;
        ctx.lineTo(x, y);
        rot += step;
    }
    ctx.lineTo(cx, cy - outerRadius);
    ctx.closePath();
    ctx.fill();
}

// --- TIMELINE UI ---

function renderTimeline() {
    const container = document.getElementById('tracks-container');
    container.innerHTML = '';
    
    state.layers.forEach((layer, index) => {
        const track = document.createElement('div');
        track.className = 'layer-track';
        
        const block = document.createElement('div');
        block.className = `layer-block ${layer.type} ${state.selectedLayerId === layer.id ? 'selected' : ''}`;
        
        // Calculate position
        const left = layer.startTime * PX_PER_SECOND;
        const width = layer.duration * PX_PER_SECOND;
        
        block.style.left = `${left}px`;
        block.style.width = `${width}px`;
        block.innerText = layer.type === 'text' ? layer.text : layer.name;
        
        // Timeline Click Select
        block.onclick = (e) => {
            e.stopPropagation();
            selectLayer(layer.id);
        };

        track.appendChild(block);
        container.appendChild(track);
    });
}

function updatePlayheadUI() {
    const playhead = document.getElementById('playhead');
    const scrollContainer = document.getElementById('tracks-container');
    const pos = state.currentTime * PX_PER_SECOND;
    playhead.style.left = `${pos + 20}px`; // +20 margin
    document.getElementById('time-display').innerText = formatTime(state.currentTime);
    
    // Auto scroll timeline
    if(pos > scrollContainer.scrollLeft + scrollContainer.clientWidth - 50) {
        scrollContainer.scrollLeft = pos - 50;
    }
}

function setupTimelineEvents() {
    const timeline = document.getElementById('timeline-area');
    // Scrubbing logic
    timeline.addEventListener('click', (e) => {
        // Rudimentary seeking
        const rect = timeline.getBoundingClientRect();
        const clickX = e.clientX - rect.left + document.getElementById('tracks-container').scrollLeft - 20;
        let time = clickX / PX_PER_SECOND;
        if (time < 0) time = 0;
        state.currentTime = time;
        updatePlayheadUI();
        drawFrame(); // Force redraw
    });
}

// --- CONTROLS & PROPERTIES ---

function selectLayer(id) {
    state.selectedLayerId = id;
    renderTimeline();
    updatePropertiesPanel();
    drawFrame();
}

function updatePropertiesPanel() {
    const panel = document.getElementById('properties-panel');
    panel.innerHTML = '';
    
    const layer = state.layers.find(l => l.id === state.selectedLayerId);
    if (!layer) {
        // Global properties (BG Color)
        createPropInput(panel, 'Background', 'color', state.backgroundColor, (v) => { state.backgroundColor = v; });
        return;
    }

    // Common Properties
    createPropInput(panel, 'X Pos', 'range', layer.x, (v) => { layer.x = parseInt(v); }, 0, CANVAS_WIDTH);
    createPropInput(panel, 'Y Pos', 'range', layer.y, (v) => { layer.y = parseInt(v); }, 0, CANVAS_HEIGHT);
    createPropInput(panel, 'Scale', 'range', layer.scale, (v) => { layer.scale = parseFloat(v); }, 0.1, 5, 0.1);
    createPropInput(panel, 'Rotate', 'range', layer.rotation, (v) => { layer.rotation = parseInt(v); }, -360, 360);
    
    // Type Specific
    if (layer.type === 'text') {
        createPropInput(panel, 'Text', 'text', layer.text, (v) => { layer.text = v; renderTimeline(); });
        createPropInput(panel, 'Color', 'color', layer.color, (v) => { layer.color = v; });
        createPropInput(panel, 'Size', 'range', layer.fontSize, (v) => { layer.fontSize = parseInt(v); }, 10, 200);
    }
    if (layer.type === 'shape') {
        createPropInput(panel, 'Color', 'color', layer.color, (v) => { layer.color = v; });
    }

    // Delete Button
    const btn = document.createElement('button');
    btn.className = 'btn';
    btn.innerHTML = '<span class="material-icons-round" style="color:red">delete</span>';
    btn.onclick = () => {
        state.layers = state.layers.filter(l => l.id !== layer.id);
        state.selectedLayerId = null;
        renderTimeline();
        updatePropertiesPanel();
    };
    panel.appendChild(btn);
}

function createPropInput(parent, label, type, value, onChange, min=0, max=100, step=1) {
    const group = document.createElement('div');
    group.className = 'prop-group';
    
    const lbl = document.createElement('span');
    lbl.className = 'prop-label';
    lbl.innerText = label;
    
    const input = document.createElement('input');
    input.type = type;
    input.value = value;
    if (type === 'range') {
        input.min = min; input.max = max; input.step = step;
    }
    
    input.oninput = (e) => {
        onChange(e.target.value);
    };
    
    group.appendChild(lbl);
    group.appendChild(input);
    parent.appendChild(group);
}

// --- UTILS ---

function togglePlay() {
    state.isPlaying = !state.isPlaying;
    const icon = document.getElementById('playIcon');
    icon.innerText = state.isPlaying ? 'pause' : 'play_arrow';
}

function formatTime(seconds) {
    const m = Math.floor(seconds / 60);
    const s = Math.floor(seconds % 60);
    const ms = Math.floor((seconds % 1) * 100);
    return `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}.${ms.toString().padStart(2,'0')}`;
}

// --- EXPORT SYSTEM (Real Video Download) ---

function exportVideo() {
    const modal = document.getElementById('exportModal');
    const loading = document.getElementById('loading');
    modal.classList.add('active');
    loading.style.display = 'block';
    
    // Stop playback
    state.isPlaying = false;
    state.currentTime = 0;

    // Capture Stream
    const stream = canvas.captureStream(FPS);
    const recorder = new MediaRecorder(stream, {
        mimeType: 'video/webm;codecs=vp9'
    });

    const chunks = [];
    recorder.ondataavailable = e => chunks.push(e.data);
    
    recorder.onstop = () => {
        const blob = new Blob(chunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `Project_${Date.now()}.webm`;
        a.click();
        
        modal.classList.remove('active');
        state.currentTime = 0; // Reset
    };

    recorder.start();

    // Render loop specifically for export
    let frameCount = 0;
    const totalFrames = state.duration * FPS;

    function processExportFrame() {
        if (frameCount <= totalFrames) {
            state.currentTime = frameCount / FPS;
            drawFrame();
            loading.innerText = Math.round((frameCount / totalFrames) * 100) + "%";
            frameCount++;
            requestAnimationFrame(processExportFrame); // Use RAF to ensure draw completes
        } else {
            recorder.stop();
        }
    }
    
    processExportFrame();
}

</script>
</body>
</html>
